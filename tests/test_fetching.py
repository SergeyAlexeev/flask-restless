"""
    tests.test_fetching
    ~~~~~~~~~~~~~~~~~~~

    Provides tests for fetching resources from endpoints generated by
    Flask-Restless.

    This module includes tests for additional functionality that is not already
    tested by :mod:`test_jsonapi`, the module that guarantees Flask-Restless
    meets the minimum requirements of the JSON API specification.

    :copyright: 2015 Jeffrey Finkelstein <jeffrey.finkelstein@gmail.com> and
                contributors.
    :license: GNU AGPLv3+ or BSD

"""
import datetime

from flask import json
from sqlalchemy import Column
from sqlalchemy import Integer
from sqlalchemy import Time
from sqlalchemy import Unicode

from flask.ext.restless import CONTENT_TYPE

from .helpers import dumps
from .helpers import loads
from .helpers import MSIE8_UA
from .helpers import MSIE9_UA
from .helpers import ManagerTestBase


class TestFetching(ManagerTestBase):
    """Tests for fetching resources."""

    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~flask_restless.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`TestSupport.Person`
        and :class:`TestSupport.Article` models.

        """
        super(TestFetching, self).setUp()

        class Article(self.Base):
            __tablename__ = 'article'
            id = Column(Integer, primary_key=True)
            title = Column(Unicode, primary_key=True)

        class Person(self.Base):
            __tablename__ = 'person'
            id = Column(Integer, primary_key=True)
            bedtime = Column(Time)

        class Tag(self.Base):
            __tablename__ = 'tag'
            name = Column(Unicode, primary_key=True)

        self.Article = Article
        self.Person = Person
        self.Tag = Tag
        self.Base.metadata.create_all()
        self.manager.create_api(Article)
        self.manager.create_api(Person)
        self.manager.create_api(Tag)

    def tearDown(self):
        """Drops all tables from the temporary database."""
        self.Base.metadata.drop_all()

    def test_serialize_time(self):
        """Test for getting the JSON representation of a time field."""
        now = datetime.now().time()
        person = self.Person(id=1, bedtime=now)
        self.session.add(person)
        self.session.commit()
        response = self.app.get('/api/person/1')
        assert response.status_code == 200
        document = loads(response.data)
        person = document['data']
        assert person['bedtime'] == now.isoformat()

    # def test_num_results(self):
    #     """Tests that a request for (a subset of) all instances of a model
    #     includes the total number of results as part of the JSON response.

    #     """
    #     self.manager.create_api(self.Person)
    #     for i in range(15):
    #         d = dict(name='person{0}'.format(i))
    #         response = self.app.post('/api/person', data=dumps(d))
    #         assert response.status_code == 201
    #     response = self.app.get('/api/person')
    #     assert response.status_code == 200
    #     data = loads(response.data)
    #     assert data['meta']['num_results'] == 15

    def test_alternate_primary_key(self):
        """Tests that models with primary keys that are not named ``id`` are
        are still accessible via their primary keys.

        """
        tag = self.Tag(name=u'foo')
        self.session.add(tag)
        self.session.commit()
        response = self.app.get('/api/tag/foo')
        document = loads(response.data)
        tag = document['data']
        assert tag['id'] == 'foo'

    def test_primary_key_int_string(self):
        """Tests for getting a resource that has a string primary key,
        including the possibility of a string representation of a number.

        """
        tag = self.Tag(name=u'1')
        self.session.add(tag)
        self.session.commit()
        response = self.app.get('/api/stringid/1')
        document = loads(response.data)
        tag = document['data']
        assert tag['name'] == '1'

    def test_jsonp(self):
        """Test for a JSON-P callback on a single resource request."""
        person1 = self.Person(id=1)
        person2 = self.Person(id=2)
        self.session.add_all([person1, person2])
        self.session.commit()
        response = self.app.get('/api/person/1?callback=foo')
        assert response.data.startswith(b'foo(')
        assert response.data.endswith(b')')
        document = loads(response.data[4:-1])
        person = document['data']
        assert person['id'] == '1'

    def test_jsonp_collection(self):
        """Test for a JSON-P callback on a collection of resources."""
        person1 = self.Person(id=1)
        person2 = self.Person(id=2)
        self.session.add_all([person1, person2])
        self.session.commit()
        response = self.app.get('/api/person?callback=foo')
        assert response.data.startswith(b'foo(')
        assert response.data.endswith(b')')
        document = loads(response.data[4:-1])
        people = document['data']
        assert ['1', '2'] == sorted(person['id'] for person in people)

    # TODO need to check this
    def test_get_callable_query_attribute(self):
        """Tests that a callable model.query attribute is being used when
        available.

        """
        # create aliases for the sake of brevity
        CarModel, CarManufacturer = self.CarModel, self.CarManufacturer

        # create some example car manufacturers and models
        manufacturer_name = u'Super Cars Ltd.'
        cm1 = CarManufacturer(name=manufacturer_name)
        cm2 = CarManufacturer(name=u'Trash Cars Ltd.')
        self.session.add_all((cm1, cm2))

        car1 = CarModel(name=u'Luxory deluxe L', manufacturer=cm1)
        car2 = CarModel(name=u'Luxory deluxe XL', manufacturer=cm1)
        car3 = CarModel(name=u'Broken wheel', manufacturer=cm2)
        self.session.add_all((car1, car2, car3))
        self.session.commit()

        # create a custom query method for the CarModel class
        def query(cls):
            car_model = self.session.query(cls)
            name_filter = (CarManufacturer.name == manufacturer_name)
            return car_model.join(CarManufacturer).filter(name_filter)
        CarModel.query = classmethod(query)

        response = self.app.get('/api/car_model')
        assert 200 == response.status_code
        data = loads(response.data)
        assert 2 == len(data['objects'])

        for car in data['objects']:
            assert car['manufacturer']['name'] == manufacturer_name

        for car in [car1, car2]:
            response = self.app.get('/api/car_model/{0}'.format(car.id))
            assert 200 == response.status_code
            data = loads(response.data)
            assert data['manufacturer_id'] == cm1.id
            assert data['name'] == car.name

        response = self.app.get('/api/car_model/{0}'.format(car3.id))
        assert 404 == response.status_code

    def test_specified_primary_key(self):
        """Tests that models with more than one primary key are accessible via
        a primary key specified by the server.

        """
        article = self.Article(id=1, title='foo')
        self.session.add(article)
        self.session.commit()
        self.manager.create_api(self.Article, url_prefix='/api2',
                                primary_key='title')
        response = self.app.get('/api2/article/1')
        assert response.status_code == 404
        response = self.app.get('/api2/article/foo')
        assert response.status_code == 200
        document = loads(response.data)
        resource = document['data']
        assert resource['id'] == article.id
        assert resource['title'] == article.title

    def test_correct_content_type(self):
        """Tests that the server responds with :http:status:`200` if the
        request has the correct JSON API content type.

        """
        response = self.app.get('/api/person', content_type=CONTENT_TYPE)
        assert response.status_code == 200
        assert response.headers['Content-Type'] == CONTENT_TYPE

    def test_no_content_type(self):
        """Tests that the server responds with :http:status:`415` if the
        request has no content type.

        """
        response = self.app.get('/api/person', content_type=None)
        assert response.status_code == 415
        assert response.headers['Content-Type'] == CONTENT_TYPE

    def test_wrong_content_type(self):
        """Tests that the server responds with :http:status:`415` if the
        request has the wrong content type.

        """
        bad_content_types = ('application/json', 'application/javascript')
        for content_type in bad_content_types:
            response = self.app.get('/api/person', content_type=content_type)
            assert response.status_code == 415
            assert response.headers['Content-Type'] == CONTENT_TYPE

    def test_msie8(self):
        """Tests for compatibility with Microsoft Internet Explorer 8.

        According to issue #267, making requests using JavaScript from MSIE8
        does not allow changing the content type of the request (it is always
        ``text/html``). Therefore Flask-Restless should ignore the content type
        when a request is coming from this client.

        """
        headers = {'User-Agent': MSIE8_UA}
        content_type = 'text/html'
        response = self.app.get('/api/person', headers=headers,
                                content_type=content_type)
        assert response.status_code == 200

    def test_msie9(self):
        """Tests for compatibility with Microsoft Internet Explorer 9.

        According to issue #267, making requests using JavaScript from MSIE9
        does not allow changing the content type of the request (it is always
        ``text/html``). Therefore Flask-Restless should ignore the content type
        when a request is coming from this client.

        """
        headers = {'User-Agent': MSIE9_UA}
        content_type = 'text/html'
        response = self.app.get('/api/person', headers=headers,
                                content_type=content_type)
        assert response.status_code == 200
